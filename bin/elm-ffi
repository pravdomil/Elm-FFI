#!/usr/bin/env node

try {
  main(process.argv.slice(2))
} catch (e) {
  die(String(e))
}

/**
 * @param {string[]} arguments
 */
function main(arguments) {
  const usage = "Usage: elm-ffi [--shebang] [--run] [--legacy] <file.js>..."

  const [options, files] = arguments.reduce(reduceArgument, [new Map(), []])
  if (files.length === 0) {
    die(usage)
  }

  files.forEach((a) => processFile(options, a))
  const fileCount = files.length + " " + (files.length === 1 ? "file" : "files")
  console.log("Elm FFI patched " + fileCount + ".")
}

/**
 * @param {Map<String, String>} options
 * @param {string} a
 */
function processFile(options, a) {
  let lines = require("fs").readFileSync(a, "utf-8").split("\n")

  lines = lines.map((a) => patchLine(options, a))

  if (options.has("shebang")) {
    lines.unshift("#!/usr/bin/env node")
  }

  if (options.has("run")) {
    lines[lines.length - 1] = lines[lines.length - 1].replace("(0)}", "(0)()}")
  }

  require("fs").writeFileSync(a, lines.join("\n"))
}

/**
 * @param {Map<String, String>} options
 * @param {string} a
 */
function patchLine(options, a) {
  const runFnRegex = /(\$author\$project[0-9A-Za-z_$]*\$JavaScript)\$run\('(.*)'\)/

  a = a.replace(runFnRegex, (a, b, c) => patchFunction(options, b, c.replace(/\\'/g, "'")))

  if (options.has("legacy")) {
    a = a.replace(
      "return x === y ? /*EQ*/ 0 : x < y ? /*LT*/ -1 : /*GT*/ 1;",
      "return x === y ? /*EQ*/ 0 : (x < y ? /*LT*/ -1 : /*GT*/ 1);"
    )
    a = a.replace("? (name == 'init')", "? ((name == 'init')")
    a = a.replace(": (obj[name] = exports[name]);", "): (obj[name] = exports[name]);")
    a = a.replace(/\bchar\b/g, "char_")
    a = a.replace(/Array.isArray\(/g, '(function(a) { return "length" in a })(')
    a = a.replace(/JSON.stringify\(/g, "(function(a) { return String(a) })(")
  }

  return a
}

/**
 * @param {Map<String, String>} options
 * @param {string} moduleName
 * @param {string} a
 */
function patchFunction(options, moduleName, a) {
  a.startsWith("await ") ? options.set("async", "") : options.delete("async")

  return createBindingFn(
    options,
    [
      "var result",
      createTryCatch(
        options,
        "result = { $: 0, a: _Json_wrap(" + a + ") }",
        "result = { $: 1, a: " + moduleName + "$Exception(_Json_wrap(e)) }"
      ),
      "result.$ === 0 ? callback(_Scheduler_succeed(result.a)) : callback(_Scheduler_fail(result.a))",
    ].join("; ")
  )
}

/**
 * @param {Map<String, String>} options
 * @param {string} a
 */
function createBindingFn(options, a) {
  return "_Scheduler_binding(" + createFn(options, ["callback"], a) + ")"
}

/**
 * @param {Map<String, String>} options
 * @param {string} a
 * @param {string} b
 */
function createTryCatch(options, a, b) {
  return "try { " + a + " } catch (e) { " + b + " }"
}

/**
 * @param {Map<String, String>} options
 * @param {Array<string>} params
 * @param {string} a
 */
function createFn(options, params, a) {
  return options.has("async")
    ? "async (" + params.join(", ") + ") => { " + a + " }"
    : "function (" + params.join(", ") + ") { " + a + " }"
}

/**
 * @param {[Map<String, String>, Array<String>]} acc
 * @param {string} a
 * @returns {[Map<String, String>, Array<String>]}
 */
function reduceArgument([options, arguments], a) {
  if (a.startsWith("--")) {
    const [k, ...rest] = a.split("=")
    options.set(k.substr(2), rest.join("="))
  } else {
    arguments.push(a)
  }
  return [options, arguments]
}

/**
 * @param {string} a
 */
function die(a) {
  console.error(a)
  process.exit(1)
}
